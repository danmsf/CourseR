---
title: "function-tutorial"
author: "GSTAT"
output:
  html_document:
    toc: yes
    toc_float: true
    toc_depth: 4

---

![](figures\gstat_logo.jpg)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
load("D:/G-stat/Cal_RCourse/Data/.RData")

```



<div dir=rtl>

____


# הקדמה 


עכשיו שאתם יודעים די הרבה על תכנות ב R , אנחנו נתמקד בשיעור הזה על דרכים ליעל את העבודה
שלנו ב R בעזרת כתיבת ושימוש בפונקציות.

R בבסיסה היא שפה פונקציונאלית - וככל שתשכילו להבין ולדעת איך לנצל את האופי הזה של R
כך תוכלו לעשות יותר, ולכתוב קוד יעיל, תמציתי ומובן יותר.

____

## מטרות השיעור

כתבית פונקציות בכל שפה הינה תהליך מורכב עם הרבה פרטים ודקויות

בהתאם לכך המטרה של השיעור איננה להפוך אותם למומחים לכתיבת פונקציונאלית, אלא:

* להכיר את סוגי הפונקציות השונים
* לתרגל ברמה בסיסית כתיבת פונקציות
* להכיר יישומים נפוצים של כתיבת פונקציות ב R

**עד סוף השיעור תדעו להשתמש בפונקציות בשביל לייעל את העבודה שלכם**

____

## ספרים שימושיים

גילוי נעות:


רוב החומר לשיעור הזה וכן התמונות המוצגים בו לקוחים משני ספרים של  Hadley Wickham:

* "R for Data Science"  - http://r4ds.had.co.nz/
* "Advanced R" - http://adv-r.had.co.nz/


הספר הראשון מומלץ לכולם והספר השני למי שרוצה ממש להבין לעומק איך הדברים עובדים

____


# נקודות כלליות

לפני שנגיע לפרקטיקה יש כמה נקודות כלליות שכדאי שיישבו לנו בראש:

* הכל ב R זה פונקציה
* פונקציה הוא אזרח של כבוד
* Lexical Scoping

___


## הכל ב R זה פונקציה

כל דבר שתראו ב R הוא פונקציה. אין לזה הרבה משמעות מעשית עבורכם (בשלב הזה) אבל 
כדאי לזכור זאת להמשך.

למשל האופרטור `+` הוא בעצם פונקציה עטופה בצורה יפה כאשר באמת קוראים לה כך

```{r general_1}

# This:

3+5 

# is really this:

`+`(3,5)

```

_____

## פונקציה הוא אזרח של כבוד 

פונקציה הוא אזרח של כבוד -  הוא אובייקט בדומה לכל שאר האובייקטים שאתם מכירים :

* ניתן לשמור אותו
* ניתן לאגד אותם ברשימה
* ניתן להדפיס אותו
* ניתן להעביר אותו
* ניתן לשנות אותו
* ועוד...

למי שלא בא משפה פונקציונאלית זה יראה קצת מוזר בהתחלה...

____________

## Lexical Scoping

הנושא הזה הוא קצת מתקדם אבל רצוי הבנה בסיסית שלו...

___

ב R אין מושג של `local` ו `global` כפי שיש ברוב השפות הפונקציונאליות.

גם אין מושג של משתני `macro`   או `scalar` כפי שאתם מכירים.

**הכל פשוט - קיים או שהוא לא קיים**

___

אבל, בדומה למושגים הללו, R עובד על שיטת ה Lexical Scoping 

בגדול זה אומר שכש R מריץ פונקציה הוא מחפש בסביבה המיידית ואם הוא לא מוצא הוא מחפש בסביבה
(environment)
 היותר רחוקה, וחוזר חלילה
עד שהוא מוצא או לא מוצא.


____


כמשל, אם אתם מחפשים את המפתחות לאוטו שאיבדתם:
+ קודם תחפשו בכיסים 
    + ואז בחדר
        + ואז בכל הבית
            + ואז בכל היקום

עד שתמצאו :)

___


בפרט, בכתיבת פונקציות:

 כש R נמצא בתוך פונקציה הוא מחפש את השמות המוכרים לו בתוך
העולם של הפונקציה שהוא נמצא בה - רק אם הוא לא מוצא הוא יחפש את אותו שם בסביבה הרחבה יותר.

בהקשר הזה כדאי לכם לקרוא על האופרטור `->>`

____


# סוגי פונקציות

בגדול יש 3 סוגים כלליים של פונקציות שנעבוד אתם ב R:

1. פונקציות שמיות
2. פונקציות אננונימיות
3. פונקציות מרמה גבוהה

____


**נתחיל בללמוד על פונקציות שמיות כאשר העקרונות שנלמד יהיו נכונות גם לשאר הסוגים**

_________


## פונקציות שמיות

מייצרים פונקציה שמית כפי שמייצרים כל אובייקט ב R, עם אופרטור ההשמה.

הצורה הבסיסית להגדרת פונקציה היא בעזרת קריאת לפקודה function בצורה ההבאה:

<div dir="ltr">
```{r name_function1}

print_hello <- function(){
                              print("hello world")
                              }

```

</div>


_____

וקוראים לפונקציה כפי שהיינו קוראים לכל אובייקט אחר



<div dir="ltr">
```{r name_function2}

print_hello()

```

</div>

_____


### ערך מוחזר מפונקציה

* פונקציה תמיד תחזיר את תוצאת שורת הקוד האחרונה 
* אפשר לשנות התנהגות זאת ולהחזיר תוצאה אחרת בעזרת הפקודה return


<div dir="ltr">
```{r name_function3}

# without return
give_me_x <- function(){
                            x <-1
                            x
                            
                            x <-10+x
                            x
                              }


give_me_x()

# with return
give_me_x <- function(){
                            x <-1
                            return(x)
                            
                            x <-10+x
                            x
                              }

give_me_x()

```

</div>

____


### פונקציות עם ערכים

הזנת ערכים לפונקציה  תעשה בצורה ההבאה:


<div dir="ltr">
```{r name_function4}
give_me_x <- function(x){
                          x <- x + 10
                          x
                              }

give_me_x(4)

```

</div>

וכעת ניתן להשתמש בנתונים שהוזנו כאובייקטים לכל דבר בתוך הפונקציה.

**חשוב: שמות של עמודות המוזנות לפונקציות מתורגמות כמחרוזת טקסט רגיל**

אם מתייחסים לשמות של עמודות בתוך פונקציות יש כמה אופציות:

1. ב dplyr  לכל פקודה יש מקבילה המסתיימת עם `_` היודעת להבין טקסט
    + אם מערבבים באותו שורה עמודה עם טקסט ועמודה בלי צריך לציין זאת בעזרת interp.
    + ככלל רוב הפעולות עובדות בפשטות - חוץ מ `mutate` שם צריך לרוב להשתמש ב `interp`
    + `interp` היא פקודה מספריית `lazyeval`

2. לעשות את המנפולציה ב BASE R ולקרוא לפונקציה מתוך שרשור של dplyr
     
3. שימוש בסימון `[[]]` ב BASE R



<div dir="ltr">
```{r name_function5}

########################################
# option 1: this works fine

sum_pop_by_col <- function(by_col){
   N_month_seg %>% 
    group_by_(by_col) %>%
    summarise(total_pop = sum(n_pop, na.rm = TRUE))
}

h <- sum_pop_by_col("segmento")

# print
h

########################################
# option 1b: this is a pain - adding a value to a coloumn

library(lazyeval)

add_pop_val <- function(by_col, value){
  mut_call <-interp(~(a + b)
                    , a = as.name(by_col)
                    , b = as.numeric(value))
  
   N_month_seg %>% 
    mutate_( .dots = setNames(list(mut_call), "new_col_name"))
}

h <- add_pop_val("n_pop",5)
h <- h %>% select(n_pop, new_col_name)

# print
h %>% slice(1:5)

########################################
# option 2: same as above but much easier

add_pop_val <- function(by_col, value){
  by_col + value
}

h <- N_month_seg %>% 
  mutate( new_col_name = add_pop_val(n_pop,5)) %>% 
  select(n_pop, new_col_name)

# print
h %>% slice(1:5)


#########################################

# option 3 : select columns with [[]]

select_by_col <- function(by_col){
   N_month_seg[[by_col]]
}

h <- select_by_col("segmento")

# print
h[20:25]

########################################
```

</div>

**שימו לב להזין את שמות העמודות בגרשיים**


ראו vignette של NSE ב dplyr לעוד פרטים

____________


### פונקציות עם ערכים בלתי מוגדרים

הזנת מספר ערכים בלתי מוגדרים לפונקציה תעשה בעזרת הסימון `...` למשל:


<div dir="ltr">
```{r name_function6}

simple_text <- function(x,...){
  paste(x, ...)
}

simple_text("hi", "how", "are", "you")

```

</div>

____


## פונקציות אננונימיות

אחד הדברים הכי יעילים ב R זה האפשרות להפעיל פונקציה מורכבת בצורה חד פעמית.

דבר זה שימושי במיוחד ברגע שנתשמש בפונקציות apply למיניהן....

קריאה לפונקציה נעשת באותה צורה רק מבלי להשתמש באופרטור ההשמה:


<div dir="ltr">
```{r unnamed_function1}

(function(x) x^2)(4)

```

</div>

אנחנו נראה את הכוח של זה ממש עוד מעט...


____________




## פונקציות מסדר גבוה

פונקציות מסדר גבוה היא פונקציה המקבלת בתור פרמטר פונקציה אחרת או מחזיר פונקציה כתוצאה.


בגדול אלה מתחלקים לשני סוגים עיקריים:


* Closures - פונקציות המחזירות פונקציות לאחר שינוי
* Functionals - פונקציות המקבלות פונקציות כפרמטר

לסוג השני של פונקציות גבוהות נקדיש פרק נפרד

____________


### Closures - פונקציות המחזירות פונקציות 

היכולת להגדיר פונקציה מתוך פונקציה הוא דבר **מאוד** שימושי....

למעשה הוא מאפשר יצירת "מפעלים ליצירת פונקציות"

למשל:


<div dir="ltr">
```{r closure_function1}

power <- function(exponent) {
  function(x) {
    x ^ exponent
  }
}


square <- power(2)
square(2)


cubed <- power(3)
cubed(2)


```

</div>



____________


# פונקציות וקטוריות -  Functionals

הדבר שהכי הרבה תשתמשו בו ב R הוא פונקציות פונקציונאליות המקבלות בתור פרמטרים פונקציות אחרות.

המשפחה הכי שימושים של פונקציות האלה הוא משפחת ה `apply` - המקבלת בתור פרמטר:

1. רשימה של ערכים (list)
2. פונקציה לביצוע

ומפעילה את הפונקציה עבור כל ערך ב list שהוזן.

אנו נלמד על `lapply` ונכיר את החברים שלו שפועלים באופן דומה.

לאחר מכן נכיר בקצרה את החבילה `purrr` העושה אותו דבר בצורה יותר מבוקרת.

_______


## lapply

`lapply` לוקחת בתור פרמטרים רשימה ופונקציה ומחזירה **תמיד** רשימה.

היא פועלת בערך כך:


![](figures\lapply.png)
 
 <!-- http://adv-r.had.co.nz/diagrams/lapply.png -->


_______

### שיטות לשימוש ב lapply

כפי שב loop רגיל שאתם מכירים יש 3 דרכים בסיסיים לעבור בתוך ה loop , כך יש 3 דרכים
לעבוד עם lapply:


1. לפי חלקים השייכים לרשימה:

<div dir="ltr">

>              in a for loop:  for (x in xs)  
>              in lapply:      lapply(xs, function(x) {})  

</div>


2. לפי מיקום ברשימה


<div dir="ltr">

>              in a for loop:  for (i in seq_along(xs))  
>              in lapply:      lapply(seq_along(xs), function(i)   {})  
 

</div>

 
3. לפי שמות של ערכים ברשימה

 
<div dir="ltr">
  
>              in a for loop:  for (nm in names(xs))  
>              in lapply:      lapply(names(xs), function(nm) {})   

</div>

_____


**כיוון ש dataframe הוא סוג של list  המאגדת וקטורים  בתור עמודות - אפשר להשתמש בו כדי לבצע פעולות על כל עמודה**



<div dir="ltr">
```{r lapply_function1}

# 1. loop over everything
lapply(N_month_seg, is.character)

# 2. loop over places
seq_along(N_month_seg)

lapply( c(1,3,5) ,
       function(i) is.numeric(N_month_seg[[i]])
       )

# 3. loop over names
names(N_month_seg)

lapply(c("sum_cc", "segmento"),
       function(nm) {is.numeric(N_month_seg[[nm]])}
       )

```

</div>


___

### הפעלה על מקומות שונים בפונקציה

* הפונקציה פועלת על הערך הראשון. 

* אם רוצים לשנות ערך אחר אפשר בעזרת פונקציה אנונימית.

<div dir="ltr">
```{r lapply_function2}

# regular option

x <- list(a = seq(0,100, by=5), b = rnorm(100))

lapply(x, function(x) mean(x, na.rm = T))

# another option

lapply(c(2,5),function(x) mean(rnorm(1000, mean = x))) 

```

</div>

_____


* מקרה יוצא דופן הוא להפעיל על רשימה של פונקציות כך: 


<div dir="ltr">
```{r lapply_function3}

funcs <- c(mean, max, min)

lapply(funcs, function(f){f(N_month_seg$sum_cc, na.rm = T)})

```

</div>



___

## חברים של `lapply`

אם רוצים שהפונקציה תחזיר וקטור במקום רשימה משתמשים באחד הפקודות הבאות:

* `sapply` - מחזיר וקטור מהסוג שהכי נראה לו לנכון
* `vapply` - מחזיר וקטור מהסוג המוגדר בפונקציה

אבל אנחנו נעדיף להשתמש בחבילת `purrr`

____

# חבילת `purrr`

חבילת `purrr` נועדה להוסיף קונסיסטנטיות לפונקציות הבסיסיות של R.

בגלל ש R לא תמיד צפוי  ביחס לסוג הוקטור שהוא מחזיר מהפעולות הוקטוריות
המתוארים לעיל - מומלץ לעשות שימוש בפונקציות מספריית `purrr` שהן הרבה יותר
מקפידות על כללים של מה נכנס ומה יוצא....

בהמשך המצגת יעשה שימוש בפונקציות של `purrr` כשבכל קטע תהיה הפניה לפונקציה המקבילה 
ב BASE R.

הפקודות של `purr` תמיד מתחילות בשם הפונקציה בסיומת `_` סוג הוקטור
שהפונקציה מחזירה. כאשר הסוגים האפשריים הם:

<div dir="ltr">

* chr - character
* lgl - logical
* int - integer
* dbl - numeric double
* df - data frame

</div>


אם אין סיומת זה מחזיר `list`.

למשל `map_dbl` מבצעת את פקודת `lapply` ומחזירה וקטור נומרי.

**ככה תמיד יודעים מה נכנס ומה יוצא - ואם יש טעות יודעים על זה מיד**


______


## פונקציות מיפוי מסוג lapply

הפקודה המקבילה ל `lapply` היא `map` כאשר היא מחזירה `list`.

אם מוסיפים סיומת אחרת היא תחזיר וקטור מהסוג הרצוי.

למשל:

<div dir="ltr">
```{r map_1}

library(purrr)

x <- list(a = seq(0,100, by=5), b = rnorm(100))

# return list
map(x, function(x) mean(x, na.rm = T))

# return numeric vector
map_dbl(x, function(x) mean(x, na.rm = T))

# return data frame
map_df(x, function(x) mean(x, na.rm = T))

# return character vector
map_chr(x, function(x) mean(x, na.rm = T))

```

</div>

_____________


## מיפוי על מספר וקטורים

כל זה טוב ויפה - אבל מה אם רוצים להפעיל פונקציה על יותר משני וקטורים במקביל?

לצורך זה משתמשים באחד הפקודות:

* `map2` - למיפוי על 2 וקטורים במקביל

<div dir="ltr">

> map2(.x, .y, .f, ...)

</div>

או 

* `pmap` - למיפוי על מספר וקטורים במקביל 



<div dir="ltr">

> pmap(.l1, .l2, .l3, ..ln, .f, ...)

</div>


כאשר .f  היא פונקציה וכל מה שבא לפני הפונקציה מובן כרשימה לעבור לעיבוד מקביל לפונקציה  



למשל:


<div dir="ltr">
```{r map2_1}

mu <- list(5, 10, -3)
sigma <- list(1, 5, 10)

map2(mu, sigma, rnorm, n = 5) %>% str()

```

</div>

בתמונה זה מה שקרה

![](figures\lists-map2.png)

פקודות מקבילות ב R BASE:  

* `map`
* `mapply`

________

## ביצוע לפי תנאים

אם רוצים לבצע פעולה כזו בהינתן תנאי מסוים נשתמש באחד מהפקודות:



* `keep` - לבצע על חלקים מהרשימה העומדים בתנאי
* `discard`  - לבצע על חלקים מהרשימה שלא עומדים בתנאי
* `detect` - החזר ערך ראשון העומד בתנאי
* `detect_index` -  החזר מיקום ערך ראשון העומד בתנאי
* `head_while` - החזר n ערכים ראשונים העומדים בתנאי
* `tail_while` - החזר n ערכים אחרונים העומדים בתנאי


<div dir="ltr">
```{r predicates_1}
# before
names(N_month_seg)

# after1
keep(N_month_seg, is.numeric) %>% str() 

# after2
discard(N_month_seg, is.numeric) %>% names()

```

</div>


פקודות מקבילות ב R BASE:


* `Filter` 
* `Find `
* `Position`

________


## ביצוע בצורה איטרטיבית

לפעמים אנו רוצים לבצע פונקציה בצורה איטרטיבית - כל פעם לפי זוגות.

כלמור, לבצע על שני הערכים הראשונים, ואת התוצאה לבצע עם הערך השלישי וחוזר...

במקרה כזה נשתמש ב:

* `reduce` - בצע פעולה באופן איטרטיבי ותחזיר את התוצאה הסופית
* `accumulate` - בצע פעולה באופן איטרטיבי ותחזיר גם את תוצאות הביניים

שימוש אחד נפוץ הוא לחבר טבלאות עם אותו מפתח, בזה אחר זה:


<div dir="ltr">
```{r reduce_1}

c(1:10)

reduce(c(1:10),sum)

accumulate(c(1:10),sum)


```

</div>

פקודה מקבילה ב R BASE:  

* `Reduce`
* `Aggregate`

____

## ביצוע על רשימה של פונקציות

לפעמים נרצה מספר פונקציות על וקטור מסוים של נתונים.

נעשה זאת בעזרת הפקודה:

* `invoke_map` - בצע מספר פקודות עם פרמטרים משתנים על וקטור

*גם כאן התוצה תלויה בסיומת הפקודה*


<div dir="ltr">
```{r invoke_map_1}

f <- c("runif", "rnorm", "rpois")
param <- list(
  list(min = -1, max = 1), 
  list(sd = 5), 
  list(lambda = 10)
)

invoke_map(f, param, n = 5) %>% str()

```


</div>

וזה מה שזה עשה


![](figures\lists-invoke.png)



____________

## פונקציות לפעולות לוואי

הרבה פעמים נרצה לבצע פונקציה לשם פעולת הלוואי שהיא מבצעת ולא לצורך החזרת תוצאה
מסוימת. למשל, אם נרצה גרף לכל קבוצה בנפרד, או לשמור גרף לכל קבוצה בנפרד.


במקרים כאלה עדיף להשתמש באחד הפקודות הבאות (הפעם אין צורך בסיומת)


* `walk` - בצע על כל ערך ברשימה
* `walk2` - בצע על כל ערך בשתי רשימות במקביל
* `pwalk` - בצע על כל ערך במספר רשימות במקביל


היתרון בשימוש בהן הוא שאם רוצים לשמור לאובייקט - אז הוא גם מחזיר את הנתונים 
ששומשו לצורך ביצוע הפעולה - אחרת הוא לא מחזיר אותן...


<div dir="ltr">
```{r walk_1}

walk(c("renta","age"), function(x)hist(Santander_sample[[x]]))


```

</div>

___

## קיצורי דרך ב `purrr`

יש שלושה קיצורי דרך שימושיים ב `purrr` שעוזרים לכתוב קוד בצורה יותר מהירה:

1. שימוש ב `~` ו `.` במקום בסינטקס של יצירת פונקציה אנונימית

למשל


<div dir="ltr">
```{r short_1}

x <- list(a = seq(0,100, by=5), b = rnorm(100))

# Instead of:
map_dbl(x, function(x) mean(x, na.rm = T))

# Use:
map_dbl(x, ~mean(., na.rm = T))

```

</div>


_____

**שני הקיצורים הבאים קשורים לבחירת וקטור מתוך רשימה**

2. שימוש בשם של וקטור באופן פשוט במקום בסימן `$`
3. שימוש במיקום של וקטור באופן פשוט במקום בסימן `$`

שני הקיצורים האלה ביחד עם כל פעולה `_map` שתרצו, מאפשרים שליפה מהירה ויעילה
של חלקי רשימות.

לדוגמא:


<div dir="ltr">
```{r short_23}

x <- list(list(1, n = 2, 3), list(4, n = 5, 6), list(7, n = 8, 9))

x %>% map_dbl(2)

# or
x %>% 
map_chr("n")


```

</div>

________

## מה אין ב `purrr`

אין ב `prurr` פונקציות וקטוריות שפועלים על מטריצות בשביל זה תצטרכו
להשתמש בפקודות מ R BASE כגון:

* `sweep`
* `outer`
* `apply`

פקודה אחרת נפוצה היא tapply , שבמהותו עושה מה שלמדתם לעשות בעזרת dplyr בפקודות `group_by` ו `summarise`:



<div dir="ltr">
```{r tapply_1}

tapply(N_month_seg$n_pop, N_month_seg$segmento, mean)
```

</div>

_____

# מה לא הספקנו

## נושאים הקשורים לרשימות

יש הרבה מאוד נושאים ודקויות שלא נגענו בהן. רובן קשורים לשימוש באובייקטים מסוג רשימה
list . 

אפנה את צומת לבכם לדרך יעילה יותר, אך מעט מורכבת של לעבוד עם טבלאות המכילות 
עמודות בהן שמורות רשימות.

מי שמעוניין שיחפש ב tidyr שימוש ב `nest`

פקודות אחרות שימושיות הקשורות לרשימות:

* `safely` - תנסה בלי להפיל את הפקודה
* `possibly` -  תנסה בלי להפיל את הפקודה - תחזיר ערך ברירת מחדל
* `transpose` - תחליף הירארכיה ברשימה

**אם תבינו לעומק איך לעבוד עם רשימות זה יקדם אתכם הרבה**

____________


## נושאים הקשורים ל `dplyr`

עוד נושאים שלא הספקנו לגעת בהן באופן פורמלי:

* שימוש ב `do` ביחד עם `dplyr` לעשות פעולה שרירותית
* שימוש ב `rowwise` ב `dplyr` לעשות חישוב לפי שורות ולא עמודות
* `dplyr` תמיד מחזיר טבלה
* שימוש ב `.$` בשביל לפנות לוקטור



____


</div>